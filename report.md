## LAB1

计46 杜亦清 2024010792

---
### 2.思考题

* 2A：时间限制为$1s$，则标准程序在各个测试数据上最大用时应为$0.5s$，则标准程序最多可运行指令条数为$0.5/10^{-8}=5×10^{7}$条。令$10n^{2}=5×10^{7}$解得$n=\sqrt{5}×10^{3} \approx 2236$ 。**故n最大为2236**.
* 2B：同理标准程序最多可运行指令条数为$5×10^{7}$条。令$20n\log_{2} n=5×10^{7}$，该超越方程无法求得精确解，转而借助计算器估算/借助计算机求数值解(见补充)，得$n \approx 145746$。**故n最大为145746**.
  
  补充：求解程序。[参考文档](https://blog.csdn.net/fengqianlang/article/details/133863468)
  ```python
    from scipy.optimize import fsolve
    import numpy as np
    def equation(n):
        return n * np.log2(n) - 2.5e6
    n_solution = fsolve(equation, 150000)
    print(n_solution)
  ```

---
### 3. 调试和测试

* 3A：
  * solution1: `int sum = 0` 语句位置错误，应放在query的循环内，每次查询前清零。该bug通过跑测例1找出。
  * solution1通过1~3测例，认为过关。
  * solution2: 递推角标错误，`sum += rowsum[x + j][y + b] - rowsum[x + j][y];` 应改为 `sum += rowsum[x + j][y + b - 1] - rowsum[x + j][y - 1];`。该bug通过输出调试排除rowsum初始化的问题，并通过静态调试看出角标错误。
  * solution2与solution1对拍后一定时间内未报错，认为过关。
  
  * AIGC工具（使用deepseek）能够检测出以上两个bug，用时61s，并提示我应该对数组角标进行边界检查，调试能力好。
  
</br>

* 3B:我使用vscode中的c/c++插件完成调试，安装C/C++扩展后点击行号左侧可设置断点，按F5开始调试之后使用调试工具栏控制执行什么操作。还可以用"变量"窗口、"监视"窗口辅助调试。

</br>

* 3C:用当前时间初始化随机数种子，保证每次运行生成的随机数不同。（此处询问了GPT）

</br>

* 3D:执行命令大概分为以下几类：
  * 编译指令：将.cpp文件编译为可执行文件，-o参数指定了可执行文件的命名。
  ```
    system("g++ rand_input.cpp -o rand_input");
    system("g++ check_input.cpp -o check_input");
    system("g++ solution_1.cpp -o solution_1");
    system("g++ solution_3.cpp -o solution_3");
  ```
  * 输入输出重定向指令：`>`重定向输出，`<`重定向输入。
  ```
    "./rand_input > rand.in" 
    // rand_input的输出定向到rand.in文件中。
    // rand.in文件如无会新建，如有会覆盖
  ```
  * diff指令：在Unix系统（我使用Windows的wsl）上进行文件的比对。
  ```
   diff 1.out 2.out
  ```
* 3E:
  由于数据范围为$1 ≤ n, m ≤ 2,000, q ≤ 10^5, 1 ≤ x ≤ a ≤ n, 1 ≤ y ≤ b ≤ m, v(i,j) ≤ 10^5$, 矩阵最大规格为$2e3 * 2e3 = 4e6$，极端情况下矩阵中所有数累加，故需要存储的最大数值为$4 × 10^6 × 10^5 = 4 × 10^{11}$，约为$2^{38}$，溢出int的储存范围，需要用`long long int`存储。


---
### 4. 调试和测试

* 4A：思路：新增二维数组`rowcolmap[i][j]`，储存从（1，1）到（i，j）范围内所有矩阵数值之和。通过容斥原理写出递推式`sum = rowcolsum[x + a - 1][y + b - 1] - rowcolsum[x + a - 1][y - 1] - rowcolsum[x - 1][y + b - 1] + rowcolsum[x - 1][y - 1]`,在`solution_2.cpp`的基础上再减少了一层循环，实现了单次问询O(1)耗时。
  
* 4B:调用chrono库进行时间测定，单位为纳秒：
**测试1**：n in 10~100; m in 10~100 ; q in 10~20.

| 统计指标 | solution_1 (ns) | solution_2 (ns) | solution_3 (ns) |
|----------|----------------|----------------|----------------|
| 平均值   | 2116563.36      | 2093363.64      | 2341255.14      |
| 测试次数 | 28             | 28             | 28             |

**测试2**：n in 500~1000; m in 500~1000 ; q in 10~20.

| 统计指标 | solution_1 (ns) | solution_2 (ns) | solution_3 (ns) |
|----------|----------------|----------------|----------------|
| 平均值   | 179539491.03      | 184495886.59      | 189011829.84      |
| 测试次数 | 33             | 33             | 33             |


**测试3**：n in 10~100; m in 10~100 ; q in 200~400.

| 统计指标 | solution_1 (ns) | solution_2 (ns) | solution_3 (ns) |
|----------|----------------|----------------|----------------|
| 平均值   | 3768172.90      | 3595498.32      |  3663289.91      |
| 测试次数 | 104             | 104             | 104             |

**测试4**：n in 500~1000; m in 500~1000 ; q in 200~400.

| 统计指标 | solution_1 (ns) | solution_2 (ns) | solution_3 (ns) |
|----------|----------------|----------------|----------------|
| 平均值   | 236693750.61      | 212347121.21      |  215143807.21      |

到这里完成了一个基础的2*2对照测试，但是结果solution3并没有明显优于solution2。下面继续改变参数进行测试：

**测试5**：n in 500~1000; m in 500~1000 ; q in 7000~9000.

| 统计指标 | solution_1 (ns) | solution_2 (ns) | solution_3 (ns) |
|----------|----------------|----------------|----------------|
| 平均值   | 755441765.63      | 262376081.03      |  239217169.63      |

大规模scaling之后solution3微弱地优于solution2.

**测试6**：n in 500~1000; m in 500~1000 ; q in 2000~4000.

| 统计指标 | solution_1 (ns) | solution_2 (ns) | solution_3 (ns) |
|----------|----------------|----------------|----------------|
| 平均值   | 236693750.61      | 212347121.21      |  215143807.21      |

**测试7**：调整a的数值。随机增量：基准值＝1：5。
solution_1 平均值: 1160486970.41 s
solution_2 平均值: 248116496.46 s
solution_3 平均值: 207594545.25 s

**测试8**：a的数值同上，令q＝10e5。
solution_2 平均值: 600368275.45 s
solution_3 平均值: 361177364.48 s

**测试9**：由于以上均测试全程序运行时间，读入矩阵计算前缀和的时间影响大，故新增一组仅记录查询时间的实验，作为参考。
参数：n in 500~1000; m in 500~1000 ; q in 5000~10000 ; a in 1 : 5.
solution_2 平均值: 60693780.37 s
solution_3 平均值: 17220269.71 s

* 4C:
  solution1的时间复杂度为
  读入：$O(n*m)$
  查询：$O(q*a*b)$

  solution2的时间复杂度为
  读入：$O(2*n*m)$
  查询：$O(q*a)$

  solution3的时间复杂度为
  读入：$O(3*n*m)$
  查询：$O(q)$

  二位前缀和的储存方式在存储时会多花费$n*m$二重循环的时间（预处理能否优化？已优化），而在单次查询上具有以O(1)替代O(a)的优势。然而在问询次数q较小、求和矩阵行数a较小时，二位前缀和相对于一位前缀和无显著优势。
  另外，由于前面存储n*m的时间影响，我又尝试仅计算查询时间，其效果是显著的。
  故在数据规模较大（n、m），且**尤其是q、a较大**时（q以累计总体差异，a以扩大单次差异），且**仅计算查询时间**时，solution3的效果显著优于其他两者。


---
### 5. AI工具使用
* 5A:
* 5B：以下为deepseek思考24s之后的回答：
<font color="green">

为了高效支持二维整数矩阵的修改操作（更新某个数字）和查询操作（查询矩形区域内所有数字之和），推荐使用以下数据结构：

推荐数据结构
二维树状数组（2D Fenwick Tree）：这是一种扩展的一维树状数组，支持在二维矩阵上进行点更新和区间查询。它实现相对简单，且时间复杂度较低。

二维线段树（2D Segment Tree）：这是一种更通用的数据结构，也支持二维操作，但实现较复杂，常数因子较大，通常仅在需要更复杂查询（如区间更新）时考虑。对于简单的求和查询，二维树状数组通常更优。

时间复杂度
更新操作（修改某个数字）：时间复杂度为 O(log R * log C)，其中 R 是矩阵的行数，C 是矩阵的列数。

查询操作（查询矩形区域和）：时间复杂度为 O(log R * log C)。

详细说明
二维树状数组：通过维护一个二维数组（通常与原始矩阵大小相同），每个节点存储部分和。更新时，需要更新所有相关节点；查询时，通过二维前缀和的方式组合多个节点的值。初始构建数据结构需要 O(R * C * log R * log C) 时间，但之后每次操作都很高效。

二维线段树：基于树结构，将矩阵递归分割为子区域。更新和查询操作需要遍历树结构，时间复杂度同样为 O(log R * log C)，但实际运行时间可能比树状数组慢 due to higher constant factors。

选择建议
如果操作主要是点更新和区间求和，且矩阵大小较大、操作次数较多，二维树状数组是首选。

如果需要支持更复杂的操作（如区间更新），则可以考虑二维线段树，但实现难度增加。

示例代码（二维树状数组伪代码）
以下是二维树状数组的基本实现伪代码（假设矩阵从索引 1 开始）：

```python
class Fenwick2D:
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        self.tree = [[0] * (cols + 1) for _ in range(rows + 1)]
    
    def update(self, row, col, delta):
        i = row
        while i <= self.rows:
            j = col
            while j <= self.cols:
                self.tree[i][j] += delta
                j += j & -j
            i += i & -i
    
    def query(self, row, col):
        # 查询从 (1,1) 到 (row,col) 的前缀和
        s = 0
        i = row
        while i > 0:
            j = col
            while j > 0:
                s += self.tree[i][j]
                j -= j & -j
            i -= i & -i
        return s
    
    def range_query(self, row1, col1, row2, col2):
        # 查询矩形区域 [row1, row2] x [col1, col2] 的和
        return self.query(row2, col2) - self.query(row1-1, col2) - self.query(row2, col1-1) + self.query(row1-1, col1-1)
```
实际使用时，需要先将原始矩阵的值通过 update 操作插入到树状数组中。

其他考虑
如果矩阵非常庞大且更新操作极少，查询操作极频繁，可以考虑使用二维前缀和数组，但每次更新需要 O(R * C) 时间重新计算前缀和，因此不适合频繁更新的场景。

对于极端情况（如矩阵大小很小），直接暴力计算查询可能也是可行的，但通常不推荐。

总之，对于一般情况，二维树状数组提供了最优的平衡 between implementation complexity and performance.
</font>

我的疑问是，什么是二维树状数组？二维线段树？
这些使用更高级的数据结构以降低复杂度的想法是怎么提出、怎么实现的？
前缀和方法在什么时候仍然适用？（如part4中有趣的改变规模得到的不同时间优化程度）