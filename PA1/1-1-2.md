# Report of 1-1-2 Interview

杜亦清 计46 2024010792

## 1. 所使用的数据结构与算法（构思、原理、实现要点）
- 数据结构
  - **环形双向链表**，用静态数组 `people que[1000000]` 储存节点。
  - 每个节点为一个结构体，包含：`int num; people *next; people *pred;`。两个指针分别指向环中的前者和后者。
  

- 算法思路
  - **首先，初始化环。**
  使用 `head = &que[0]` 作为环的起点，`create()` 将 `head->next = head`、`head->pred = head`，形成自环。
  - **其次，逐个“就坐”，即插入节点**
    - `sitin(n,m)` 中维护指针 `p` 指向“上一次就坐”的节点。对第 i 个（i 从1到 n-1）新节点：
    - 计算实际移动步数 `k = (m-1) % i`（使用模以避免多余循环）。
    - 为减少移动次数，若 `k > i/2` 则取反向最短路径：`k = i - k` 并向 `pred` 方向（模拟顺时针方向）移动；否则向 `next` 方向（模拟逆时针方向）移动。
    - 在定位的节点后插入新节点，维护 `next`/`pred` 指针。
  - 最终返回最后插入节点，程序从该处开始通过向 `pred` 方向（模拟顺时针方向）遍历打印结果。

- 实现要点
  - 实际步长取模：用 `%` 处理大步长m（避免线性大循环）。
  - 遍历方向分支判断：双向遍历选择更短方向以减少每次定位的步数。
  - 双向指针维护：插入使用四步指针更新以保证链表一致性：
    - `new->next = p->next; p->next->pred = new; p->next = new; new->pred = p;`

## 2. 开发过程中遇到的问题与排除过程
- 问题：下标错位
  - 现象：使用 `k = m % i`（或直接 m）时，插入位置与预期不符。
  - 原因：`p` 指向“上一次就坐”的节点，而“上一个就做的人”算作“第1个人”，故若要从该节点算起走 m步到达插入点，应使用 `(m-1)` 作为移动步数，因此采用 `k = (m-1) % i`。
  - 验证方法：使用小规模样例输入逐步调试，和手工模拟对比发现问题。

- 问题：步长m大导致大量无用遍历
  - 解决：用模运算把步数约到 `[0, i-1]` 范围；再用 `k > i/2` 判定走短路（向 pred），降低每次移动次数。

- 调试技巧：打印链表（next/pred）和插入前后局部结构，即`p->num,p->next->num,p->pred-num`，使用变量监视。

- 参考资料
  - Josephus problem 相关资料
  - 常见链表操作的教材说明（上学期《程序设计基础》）

## 3. 时间复杂度与空间复杂度估算
- 时间复杂度： **$O(n^2)$**
  - 最坏情况：无进一步优化或 m 导致每次移动接近i/2，第i次插入为$min(k,i-k)$，最多$O(\frac{i}{2})$步，总步数为$Σ_{i=1}^{n-1} O(min(k,i-k))$，上界为 $O(\frac{1}{4}n^2)$。
  - 在特殊情况（如固定小m，或`m % i`很小）：接近 O(n)。
  - 两个优化点：模运算与方向选择能显著降低常数，但渐近复杂度在一般输入下仍为 **$O(n^2)$**。

- 空间复杂度：**$O(n)$**
  - 实际分配为常量上限1e6，总占用空间为$24*10^6 bytes$，约为24MB。
  - （其中24是`sizeof(people)`的返回值）
