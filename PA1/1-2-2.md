# Report of 1-2-2 Graphics

杜亦清 计46 2024010792

## 1. 所使用的数据结构与算法（构思、原理、实现要点）

### 数据结构
- **坐标数组**：使用静态数组 `u[200001]` 和 `v[200001]` 分别存储x轴和y轴上的坐标点
- **临时数组**：`tmp_arr[200001]` 用于归并排序过程中的临时存储

### 算法思路
- **问题转换**：将几何交点问题转化为数学不等式判断问题。线段OP与连接(u_i,0)和(0,v_i)的线段相交的条件是：`u_i × v_i ≤ u_i × y + v_i × x`.
  由题目条件“在平面直角坐标系中，如果在 x 正半轴和 y 正半轴上分别挑选 n 个随机点，那么不难理解，只有一种方案能将这两组点一一联接起来”，易知该表达式的值在u、v排序后是天然有序的，故可基于此设计二分查找算法。
- **预处理阶段**：使用归并排序对u和v数组分别进行排序，确保后续二分查找的正确性
- **查询阶段**：对每个查询点P(x,y)，在排序后的数组上使用二分查找确定满足条件的线段数量
```c++
  // 查询函数
int query(int x, int y)
{
    int lo = 0, hi = n - 1;
    int result = n; // 默认值，表示所有直线都满足条件

    // 二分查找：在排序后的直线数组中查找第一个不满足条件的直线
    while (lo <= hi)
    {
        // 查询区间为 [lo,hi]
        // int mi = (lo + hi) >> 1;
        int mi = lo + (hi - lo) / 2;

        // 计算判别式：p>0时无交点，需找到第一个无交点的位置
        long long p = -((long long)u[mi] * y + (long long)v[mi] * x - (long long)u[mi] * v[mi]);
        if (p > 0)
        {
            result = mi; // 记录当前位置，满足p>0
            hi = mi - 1; // 向左半部分继续查找
        }
        else
        {
            lo = mi + 1; // 向右半部分继续查找
        }
    }
    return result; // 返回，数值上等于交点个数
}
```

### 实现要点
- **判别式计算**：使用 `p = -(u[mi] * y + v[mi] * x - u[mi] * v[mi])` 作为判断条件，当p > 0时表示当前线段不与OP相交
- **二分查找优化**：采用标准的二分查找模板，使用 `lo + (hi - lo) / 2` 计算中间位置避免整数溢出
- **归并排序实现**：递归实现归并排序，确保排序的稳定性

## 2. 开发过程中遇到的问题与排除过程

### 问题1：整数溢出
<font color=red>这个问题非常关键！！！</font>
- **现象**：当坐标值接近2^31时，计算结果出现异常
- **分析**：两个int类型相乘可能超过int的最大表示范围
- **解决方法**：在乘法运算前将int强制转换为long long类型，如下：`long long p = -((long long)u[mi] * y + (long long)v[mi] * x - (long long)u[mi] * v[mi]);`。注意不能仅仅在左侧p的类型开longlong。
- 本题中，坐标值本身的储存可以用int，而坐标值计算后得到的表达式需要用longlong储存（int 范围为$[-2^{31}, 2^{31}-1]$，long long int 范围为$[-2^{63}, 2^{63}-1]$）

### 问题2：二分查找边界条件
- **现象**：某些查询结果与预期不符
- **原因分析**：二分查找的终止条件和区间更新逻辑不够清晰
- **解决方法**：采用标准的二分查找模板，明确循环终止条件为`lo <= hi`，并正确更新查找区间
- **调试技巧**：使用小规模数据手动模拟二分查找过程，验证每一步的区间更新

### 问题3：排序算法选择
- **现象**：最初尝试使用快速排序，但在某些情况下性能不稳定
- **解决方法**：改用归并排序保证O(n log n)的时间复杂度
- **优化考虑**：归并排序虽然需要额外空间，但性能稳定，适合大规模数据

### 参考资料
- 二分查找算法的标准实现
- int和long long的范围

## 3. 时间复杂度与空间复杂度估算

### 时间复杂度：O((n + m) log n)
- **排序阶段**：对两个长度为n的数组进行归并排序，时间复杂度为O(n log n)
- **查询阶段**：进行m次二分查找，每次查找时间复杂度为O(log n)，总时间为O(m log n)
- **总体复杂度**：O((n + m) log n)，对于n, m ≤ 200,000，总操作数约为7.2 × 10^6 ，计算机1s约可执行10^8次操作，程序运行时间约0.1s，在可接受范围内。

### 空间复杂度：O(n)
- **数组存储**：u、v数组各需要O(n)空间，临时数组需要O(n)空间
- **递归栈**：归并排序递归深度为O(log n)，栈空间可忽略
- **总空间占用**：约3 × 200,000 × 4 bytes = 2.4MB，远小于题目限制

## 总结
- 通过数学转换将几何问题转化为查找问题，显著降低了问题复杂度。天然的序关系为二分查找建立了基础。
- **注意开long long！！！**
- 数据规模：可以根据数据规模判断存储类型，进一步可以根据数据规模估计最多可以忍受的时间空间复杂度。
- 其他关键修改：
`int result = n // 默认值，表示所有直线都满足条件`
`int mi = lo + (hi - lo) / 2; //避免求和后溢出（一般不会）`