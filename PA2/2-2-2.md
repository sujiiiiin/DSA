# Report of 2-2-2 Polynomial

杜亦清 计46 2024010792


## 1. 所使用的数据结构与算法的构思、原理和实现要点

### 1.1 数据结构设计

**多项式结构体 (Polynomial)**
- **设计思路**：采用数组存储多项式的系数，特别地，维护一个k值作为幂次信息。
- **核心字段**：
  - `int k`：多项式的实际次数（最高次项）
  - `long long x[65]`：系数数组，`x[i]`存储x^i的系数

**双栈结构**
- **操作数栈 (opnd)**：存储Polynomial
- **操作符栈 (optr)**：存储运算符和括号

### 1.2 算法原理

**中缀表达式求值算法**
- 基于经典的运算符优先级算法
- 核心思想：通过维护操作符栈来决定运算顺序
- 处理流程：
  1. 操作数直接入操作数栈
  2. 操作符与栈顶操作符比较优先级
  3. 高优先级运算符先执行运算

**优先级表设计**
```cpp
const char pri[7][7] = {
    /* 当前: +    -    *    ^    (    )   \0 */
    /* + */ '>', '>', '<', '<', '<', '>', '>',
    /* - */ '>', '>', '<', '<', '<', '>', '>', 
    /* * */ '>', '>', '>', '<', '<', '>', '>',
    /* ^ */ '>', '>', '>', '>', '<', '>', '>',
    /* ( */ '<', '<', '<', '<', '<', '~', ' ',
    /* ) */ ' ', ' ', ' ', ' ', ' ', ' ', ' ',
    /* \0 */ '<', '<', '<', '<', '<', ' ', '~'
};
```
* ")"不会入栈
* "("小于一切
* 左右括号、'\0'之间可以匹配

### 1.3 实现要点

**多项式运算实现**
- **加法**：对应系数相加，时间复杂度O(k)
- **减法**：对应系数相减，注意负数处理，时间复杂度O(k)
- **乘法**：双重循环计算所有系数组合，时间复杂度O(k²)
- **乘方**：通过重复乘法实现，时间复杂度O(p·k²)

**输入预处理**
- 自动补全省略的乘号：
  - 数字与左括号之间：`3( → 3*(`
  - 右括号与变量之间：`)x → )*x`
  - 变量与变量之间：`x*x`
  - 数字与变量之间：`3x → 3*x`

**边界处理**
- 检查栈空条件，捕获RE
- 边计算边取模，防止整数溢出
- 特殊处理0

## 2. 完成过程中遇到的问题与解决方法

### 2.1 主要问题及解决过程

**问题1：内存超限 (MLE)**
- **现象**：最初opnd开全导致内存超限
- **分析**：多项式结构体占用较大空间（65×8=520字节）
- **解决**：
  - 优化栈大小：`opnd[300000]`，`optr[2001000]`
  - 评估实际需求，避免过度分配

**问题2：错误答案 (WA)**
- **现象**：部分测试用例（大测例）结果错误
- **分析**：
  - 整数溢出：M=10⁹，M²=10¹⁸超过int范围
  - 模运算时机不当
- **解决**：
  - 系数改为`long long`类型！
  - 在关键运算后及时取模！
  - 完善负数模运算处理：`(a%M + M)%M`

**问题3：段错误 (RE)**
- **现象**：程序运行时崩溃
- **分析**：
  - 栈操作边界检查不充分
- **解决**：
  - 添加栈空检查：`if (h_tr < 1 || h_nd < 2)`
  - （实现一元负号处理：压入0作为左操作数）
  - 最终用退出码调试发现 c1 == '(' 而 mapping[c1] == 4 的问题，发现是在这个测例下 S 数组开的不够大爆了，溢出重写了mapping数组的内存区域。离谱

**问题4：时间超限 (TLE)**
- **现象**：处理大规模输入时超时
- **分析**：
  - 多项式乘法优化不足，对于稀疏乘法会有大量循环空转
- **解决**：
  - 在乘法中添加检查系数是否为0，如果为0直接continue

### 2.2 调试技巧与方法

- 单步调试，跟踪栈状态变化
- include <cstdlib> 之后，使用特殊退出码标识不同错误类型
- 构造特殊测例

## 3. 时间和空间复杂度分析

### 3.1 时间复杂度分析

**表达式解析**
- 读入（`void read()`）：O(n)，n为输入字符串长度
- 求值（`void evaluate()`）：O(n)，每个字符处理一次

**多项式运算**
- 加法/减法：O(k)，k为多项式次数（k≤64）
- 乘法：O(k²)，双重循环计算系数
- 乘方：O(p·k²)，p为指数（p≤4）

**总体时间复杂度**
- **最坏情况：O(n·k²)**
- 由于k≤64为常数，实际复杂度可视为O(n)
- 对于稀疏乘法做了特殊优化！

### 3.2 空间复杂度分析

**栈空间**
- 操作数栈：3e5 × ( 65 × 8 + 1 ) 字节 ≈ 156MB
- 操作符栈：2e6 × 1字节 ≈ 2MB
- 实际栈长度峰值与具体输入有关

**其他存储**
- 输入字符串：5e6字节 ≈ 5MB
- 临时变量：可忽略不计

**总空间**
- 约163MB，满足256MB限制
- 多项式结构体是主要内存消耗，操作数栈不能开太大！

**总空间复杂度**
- **总空间复杂度为 O(n)**
- 具体来说 = n + 1/3 n + 2/3 n * （ 65 * 8 + 1 ）
- 由于省略了的乘号被补全，实际的n可能会更大一些
