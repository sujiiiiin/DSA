# Report of 2-2-2 Risks

杜亦清 计46 2024010792

## 一、数据结构与算法的构思、原理和实现要点

### 1. 核心数据结构

**最大值队列 (Max Queue)**
- **构思**：使用双端队列维护当前窗口内的最大值，队列保持下标对应的xlist值单调递减
- **原理**：队列头部存储当前窗口最大值下标，新元素从尾部插入时，移除所有小于它的元素
- **实现要点**：
  - 使用数组`Maxqueue`模拟双端队列，`mf`和`mb`分别表示队首和队尾
  - 存储下标而非值，便于判断元素是否在窗口内
  - 保证队列单调递减：新元素入队前，从队尾移除所有小于它的元素

### 2. 主要算法流程

**滑动窗口最大值计算**
```cpp
void calculate(int pos, long long int mi)
```
- 输入：当前位置`pos`，查询天数`mi`
- 处理：
  1. 调整窗口边界：`mi = min(mi, pos)`防止越界
  2. 移除队首过期元素：`Maxqueue[mf] < pos - mi`
  3. 获取当前窗口最大值：`maxlist[pos] = xlist[Maxqueue[mf]]`
  4. 维护队列单调性：从队尾移除小于当前元素的元素，然后入队

**查询处理优化**
- 预处理：对`maxlist`数组进行归并排序
- 二分查找：使用`search`函数快速统计区间元素数量
- 查询响应：`O(log n)`时间完成每个查询

## 二、遇到的问题与解决方法

### 1. 主要问题

**边界条件处理**
- 空队列情况：当`mf >= mb`时，`maxlist[pos]`设为0
- 窗口大小限制：`mi > pos`时，`mi = pos`防止查询第0天之前的数据

**算法设计问题**
- 这是最核心的一个！
- 开始我试图维护一个储存最大值本身的数组，每次滑动窗口时再依次取出值来更新最大值，但实际上可以直接存储最大值点的索引，然后比较就方便多了，减少了进出栈的过程。但是这还不是核心的效率瓶颈。

**算法效率瓶颈**
- 预处理 + 查询型的，考虑完处理还要考虑查询！
- 初始设计：每次查询都遍历整个数组，时间复杂度O(t×n)=10¹¹
- 优化方案：预处理排序 + 二分查找，将查询复杂度降为O(t×log n)

**数组越界问题**
- **现象**：小数据测试通过，大数据测试失败
- **原因**：数组大小不足（初始设为100001，实际需要1000001）
- **解决**：将所有数组大小调整为`1000001`

### 2. 调试技巧

**双重验证机制**
```cpp
void query(long long int p, long long q)     // 优化版本
void queryright(long long int p, long long q) // 暴力验证版本
```
- 同时运行两种实现，对比结果确保正确性
- 暴力版本用于验证优化算法的正确性

## 三、时间与空间复杂度分析

### 1. 时间复杂度

**主算法阶段**：
- **滑动窗口计算**：O(n)
  - 每个元素入队一次、出队一次，均摊复杂度O(1)！
  - n次调用，总复杂度O(n)

- **排序阶段**：O(n log n)
  - 归并排序，标准复杂度O(n log n)

- **查询处理**：O(t log n)
  - 每次查询两次二分查找，每次O(log n)
  - t次查询，总复杂度O(t log n)

**总时间复杂度**：**O(n log n + t log n)**

### 2. 空间复杂度

**主要数组**：
- `xlist[1000001]`：存储原始数据 → O(n)
- `Maxqueue[1000001]`：单调队列 → O(n)  
- `maxlist[1000001]`：最大值结果 → O(n)
- `tmp[1000001]`：归并排序临时数组 → O(n)

**总空间复杂度：O(n)**

### 3. 实际性能
- n = 10⁶, t = 10⁵时：
  - 时间：n log n ≈ 2×10⁷，t log n ≈ 1.7×10⁶，总计可行
  - 空间：4×10⁶×4B ≈ 16MB，内存充足
